/** textBuffer.c
\brief
\author    William J Giddings email: wjgiddings@blueyonder.co.uk
\date      12-Jan-2010
\version   0.9.94
\note      Module generated by gnocl_template_assistant.
            Much of the code wil be shared with text.
            The idea is to directly edit text into a GtkTextView widget,

**/

#include "gnocl.h"
#include <string.h>
#include <assert.h>

/**
\brief
\author     William J Giddings
\date       12-Jan-2010
\since      0.9.94
**/

static const int textIdx = 0;
static const int Option2Idx = 1;

static GnoclOption textBufferOptions[] =
{
	/*  widget custom options, later processed by configure */
	{ "-text", GNOCL_STRING, NULL },      /* option1Idx = 0 */
	{ "-option2", GNOCL_STRING, NULL},       /* option2Idx = 1 */

	/* class specific properties go here */

	/* class specific signals go here */

	/* used by most widgets, delete if uncessary */
	{ "-tooltip", GNOCL_OBJ, "", gnoclOptTooltip },

	/* GtkWidget properties common to all gnocl widgets */
	{ "-data", GNOCL_OBJ, "", gnoclOptData },
	{ "-name", GNOCL_STRING, "name" },

	{NULL}
};

/**
\brief
\author     William J Giddings
\date       12-Jan-2010
\since      0.9.94
**/
static int cget ( Tcl_Interp *interp, GtkTextBuffer *widget, GnoclOption options[], int idx )
{
	return gnoclCgetNotImplemented ( interp, options + idx );
}

/**
\brief
\author     William J Giddings
\date       12-Jan-2010
\since      0.9.94
**/
static int configure ( Tcl_Interp *interp, GtkTextBuffer *widget, GnoclOption options[] )
{

	if ( options[textIdx].status == GNOCL_STATUS_CHANGED )
	{
		printf ( "Insert some text at creation\n" );
		char *str = options[textIdx].val.str;
		gtk_text_buffer_set_text ( widget, str, -1 );
	}

	if ( options[Option2Idx].status == GNOCL_STATUS_CHANGED )
	{
		printf ( "Do something here for -option2 \n" );

	}

	return TCL_OK;
}

/**
\brief
\author     William J Giddings
\date       12-Jan-2010
\since      0.9.94
**/
int textBufferFunc ( ClientData data, Tcl_Interp *interp, int objc, Tcl_Obj * const objv[] )
{

	/* set list of valid commands for this widget */
	static const char *cmds[] = { "insert", "class", "delete", "configure", "cget", "show", "hide", NULL };
	enum cmdIdx { InsertIdx, ClassIdx, DeleteIdx, ConfigureIdx, CgetIdx, ShowIdx, HideIdx };

	int idx;
	GtkTextBuffer *widget;

	widget  = GTK_TEXT_BUFFER ( data );

	/* check the number of arguments received from the interpreter */
	if ( objc < 2 )
	{
		Tcl_WrongNumArgs ( interp, 1, objv, "command" );
		return TCL_ERROR;
	}

	/* get which command was passed */
	if ( Tcl_GetIndexFromObj ( interp, objv[1], cmds, "command", TCL_EXACT, &idx ) != TCL_OK )
	{
		return TCL_ERROR;
	}

	/* respsond to the commands received */
	switch ( idx )
	{
			/* return class of widget */
		case ClassIdx:
			{
				Tcl_SetObjResult ( interp, Tcl_NewStringObj ( "TEMPLATE_CLASS", -1 ) );
			}
			break;
			/* detroy the widget */
		case DeleteIdx:
			{
				//return gnoclDelete ( interp, GTK_TEXT_BUFFER ( widget ), objc, objv );
				gtk_object_destroy ( widget );
				return TCL_OK;
			}
			/* re-configure widget settings */
		case ConfigureIdx:
			{
				int ret = TCL_ERROR;

				if ( gnoclParseAndSetOptions ( interp, objc - 1, objv + 1, textBufferOptions, G_OBJECT ( widget ) ) == TCL_OK )
				{
					ret = configure ( interp, widget, textBufferOptions );
				}

				gnoclClearOptions ( textBufferOptions );

				return ret;
			}

			break;
			/* obtain current values for valid options */
		case CgetIdx:
			{
				int     idx;

				switch ( gnoclCget ( interp, objc, objv, G_OBJECT ( widget ), textBufferOptions, &idx ) )
				{
					case GNOCL_CGET_ERROR:
						return TCL_ERROR;
					case GNOCL_CGET_HANDLED:
						return TCL_OK;
					case GNOCL_CGET_NOTHANDLED:
						return cget ( interp, widget, textBufferOptions, idx );
				}
			}
		case InsertIdx:
			{
				printf ( "insert command not yet implemented.\n" );
			}
			break;
	}

	return TCL_OK;
}

/**
\brief
\author     William J Giddings
\date       12-Jan-2010
\since      0.9.94
**/
int gnoclTextBufferCmd ( ClientData data, Tcl_Interp *interp, int objc, Tcl_Obj * const objv[] )
{

	int ret;
	GtkTextBuffer *widget;

	/* 1) check the validity of the options passed from the interpeter */
	if ( gnoclParseOptions ( interp, objc, objv, textBufferOptions ) != TCL_OK )
	{
		gnoclClearOptions ( textBufferOptions );
		return TCL_ERROR;
	}

	/* 2) initialize the widget and set options passed from the interpreter */
	widget = gtk_text_buffer_new ( NULL );

	/* a) apply base widget properties and signals */
	ret = gnoclSetOptions ( interp, textBufferOptions, G_OBJECT ( widget ), -1 );

	/* b) apply options not handled above */
	if ( ret == TCL_OK )
	{
		ret = configure ( interp, widget, textBufferOptions );
	}

	/* c) free up memory */
	gnoclClearOptions ( textBufferOptions );

	/* d) in the case of invalid options, destroy the widget instances and quit */
	if ( ret != TCL_OK )
	{
		gtk_object_destroy ( widget );
		return TCL_ERROR;
	}

	/* 3) everything is ok, so realize the widget */
	/* doesn't apply to the GtkTextBuffer */
	//gtk_widget_show ( GTK_WIDGET ( widget ) );

	/* 4) register the widget with the interpreter and associate it with a handler function */

	const char *name;
	name = gnoclGetAutoWidgetId();
	gnoclMemNameAndWidget ( name, widget );

	Tcl_CreateObjCommand ( interp, ( char * ) name, textBufferFunc, widget, NULL );

	Tcl_SetObjResult ( interp, Tcl_NewStringObj ( name, -1 ) );
	//return gnoclRegisterWidget ( interp, GTK_WIDGET ( scrolled ), textFunc );
	return TCL_OK;
}


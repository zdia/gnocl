/** pixBuf.c
\brief     pixBufs are offscreen drawables.
\author    William J Giddings email: wjgiddings@blueyonder.co.uk
\date      17-Jan-2010
\version   0.9.94
\note      Module generated by gnocl_template_assistant.
\bugs       SVG rotation and composition produce errors.
\history
            09/04/10    pixbuf command
                            duplicate
            15/03/10    pixbuf command
                            info
            05/03/10
                        pixbuf command
                            setPixel

            02/03/10    pixbuf command
                            get drawable | image
                            render

            26/02/10    pixbuf command
                            subpixbuf
            20/02/10    pixbuf command
                            copy
            16/02/10    pixbuf command
                            draw
            15/02/10
                        pixbuf commands
                            composite
                            resize
                            scale
            14/02/10
                        pixbuf commands
                            turn
                            flip
                            rotate
                        commands
                            load

            13/02/10    pixbuf commands
                            save
                            fill
                            class
            12/02/10    commands
                            new
            11/02/10    commands
                            types
                            description <type>
                            license | licence <type>
                            extension <type>
                            scaleble <type>
                            writable <type>
                            fileInfo <fileName>
\todo
        1) Resolve what acolor actually does.
        2) Perform alpha channel operations.
            set, erase, get
**/

#include "gnocl.h"
#include <string.h>
#include <assert.h>


static cairo_t   *pixbuf_cairo_create ( GdkPixbuf *pixbuf );
static GdkPixbuf *pixbuf_cairo_destroy ( cairo_t *cr, gboolean   create_new_pixbuf );
GdkPixbuf *gnoclGetPixBufFromName ( const char *id, Tcl_Interp *interp );
const char *gnoclGetNameFromPixBuf ( GdkPixbuf *pixbuf );
static guint32 convertRGBtoPixel ( gchar *clr );
static void set_pixel_color ( GdkPixbuf *pixbuf, int x, int y, guchar red, guchar green, guchar blue, guchar alpha );

/* needs to be public to be accessed by gnocl::inventory */
static GHashTable *name2pixbufList;
static const char idPrefix[] = "::gnocl::_PBUF";

/*
canpixbufs be created and modified using standard properties?
*/
static GnoclOption pixBufOptions[] =
{
	{ "-width", GNOCL_BOOL, "width"}, /* 0 */
	{ "-height", GNOCL_OBJ, "height"}, /* 1 */
	{ "-bitsPerSample", GNOCL_OBJ, "bits-per-sample"}, /* 2 */
	{ "-alpha", GNOCL_OBJ, "has-alpha"}, /* 3 */
	{ "-colorspace", GNOCL_OBJ, "colorspace"}, /* 4 */
	{ "-nChannels", GNOCL_OBJ, "n-channels"}, /* 5*/

	/* GtkObject Properties */
	{ "-data", GNOCL_OBJ, "", gnoclOptData },

	{ NULL }
};

static const int aIdx  = 0;
static const int bIdx  = 1;
static const int cIdx  = 2;
static const int dIdx  = 3;
static const int eIdx  = 4;
static const int fIdx  = 5;

void gnoclGetPixBufList ( GList **list )
{
	g_hash_table_foreach ( name2pixbufList, hash_to_list, list );
}

/**
\brief  Rotate a pixbuf through an arbitrary angle (degrees).
\author
\date   15/Feb/2010
\since  0.9.94
\note   Adaption of:
     GdkPixbuf * gdk_pixbuf_rotate(GdkPixbuf *pixbuf, double angle, int acolor)

     The returned image has the same size as the original, but the
     pixbuf envelope is increased to accomodate the rotated original
     (e.g. a 100x100 pixbuf rotated 45 deg. needs a 142x142 pixbuf).

     Pixels added around the rotated image have all RGB values = acolor.   //  v.2.17

     Angle is in degrees. Positive direction is clockwise.
     Pixbuf must have 8 bits per channel and 3 or 4 channels.
     Loss of resolution is about 1/2 pixel.
     Speed is about 18 million pixels/sec. on my 2.67 GHz CPU.             //  v.3.2

     NULL is returned if the function fails for one of the following:
         - pixbuf not 8 bits/channel or < 3 channels
         - unable to create output pixbuf (lack of memory?)

     Algorithm:
         create output pixbuf big enough for rotated input pixbuf
         compute coefficients for affine transform
         loop all output pixels
            get next output pixel (px2,py2)
            convert to input pixel (px1,py1) using affine transform        //  v.3.2
            if outside of pixmap
               output pixel = black
               continue
            for 4 input pixels based at (px0,py0) = (int(px1),int(py1))
               compute overlap (0 to 1) with (px1,py1)
               sum RGB values * overlap
            output aggregate RGB to pixel (px2,py2)
\see    http://kornelix.squarespace.com


    Note: Not really certain what the acolor variable actually does.

**/
static GdkPixbuf * pixbufRotate ( GdkPixbuf *pixbuf1, double angle, int acolor )
{
	/* 3 RGB values, 0-255 each */
	typedef unsigned char  *pixel;

	GdkPixbuf      *pixbuf2;
	GdkColorspace  color;

	int      nch, nbits, alpha;
	int      ww1, hh1, rs1, ww2, hh2, rs2;
	int      px2, py2, px0, py0;
	pixel    ppix1, ppix2, pix0, pix1, pix2, pix3;
	double   px1, py1;
	double   f0, f1, f2, f3, red, green, blue;
	double   a, b, d, e, ww15, hh15, ww25, hh25;
	double   pi = 3.141593;

	nch = gdk_pixbuf_get_n_channels ( pixbuf1 );
	nbits = gdk_pixbuf_get_bits_per_sample ( pixbuf1 );

	/* must have 3+ channels (colors) */
	if ( nch < 3 ) return 0;

	/* must be 8 bits per channel */
	if ( nbits != 8 ) return 0;

	/* get input pixbuf1 attributes */
	color = gdk_pixbuf_get_colorspace ( pixbuf1 );
	alpha = gdk_pixbuf_get_has_alpha ( pixbuf1 );
	ww1 = gdk_pixbuf_get_width ( pixbuf1 );
	hh1 = gdk_pixbuf_get_height ( pixbuf1 );
	rs1 = gdk_pixbuf_get_rowstride ( pixbuf1 );

	/* normalize, -180 to +180 */
	while ( angle < -180 ) angle += 360;

	while ( angle > 180 ) angle -= 360;

	/* radians, -pi to +pi */
	angle = angle * pi / 180;

	/*  bugfix 0.01 >> 0.001   v.2.1 */
	if ( fabs ( angle ) < 0.001 )
	{
		/* angle is zero within my precision */
		pixbuf2 = gdk_pixbuf_copy ( pixbuf1 );
		return pixbuf2;
	}

	/* rectangle containing rotated image */
	ww2 = ww1 * fabs ( cos ( angle ) ) + hh1 * fabs ( sin ( angle ) );
	hh2 = ww1 * fabs ( sin ( angle ) ) + hh1 * fabs ( cos ( angle ) );

	/* create output pixbuf2 */

	pixbuf2 = gdk_pixbuf_new ( color, alpha, nbits, ww2, hh2 );

	if ( ! pixbuf2 ) return 0;

	rs2 = gdk_pixbuf_get_rowstride ( pixbuf2 );

	/* input pixel array */
	ppix1 = gdk_pixbuf_get_pixels ( pixbuf1 );

	/* output pixel array */
	ppix2 = gdk_pixbuf_get_pixels ( pixbuf2 );

	ww15 = 0.5 * ww1;
	hh15 = 0.5 * hh1;
	ww25 = 0.5 * ww2;
	hh25 = 0.5 * hh2;

	/* affine transform coefficients   v.3.2 */
	a = cos ( angle );
	b = sin ( angle );
	d = - sin ( angle );
	e = cos ( angle );

	/* loop through output pixels */
	for ( py2 = 0; py2 < hh2; py2++ )
		for ( px2 = 0; px2 < ww2; px2++ )
		{
			/* (px1,py1) = corresponding       v.3.2 */
			px1 = a * ( px2 - ww25 ) + b * ( py2 - hh25 ) + ww15;

			/* point within input pixels */
			py1 = d * ( px2 - ww25 ) + e * ( py2 - hh25 ) + hh15;

			/* pixel containing (px1,py1) */
			px0 = px1;
			py0 = py1;

			/* if outside input pixel array */
			if ( px1 < 0 || px0 >= ww1 - 1 || py1 < 0 || py0 >= hh1 - 1 )
			{
				/* output is acolor    v.2.17 */
				pix2 = ppix2 + py2 * rs2 + px2 * nch;
				pix2[0] = pix2[1] = pix2[2] = acolor;
				continue;
			}

			/* 4 input pixels based at (px0,py0) */
			pix0 = ppix1 + py0 * rs1 + px0 * nch;
			pix1 = pix0 + rs1;
			pix2 = pix0 + nch;
			pix3 = pix0 + rs1 + nch;

			/* overlap of (px1,py1) */
			f0 = ( px0 + 1 - px1 ) * ( py0 + 1 - py1 );

			/* in each of the 4 pixels */
			f1 = ( px0 + 1 - px1 ) * ( py1 - py0 );
			f2 = ( px1 - px0 ) * ( py0 + 1 - py1 );
			f3 = ( px1 - px0 ) * ( py1 - py0 );

			/* sum the weighted inputs */
			red =   f0 * pix0[0] + f1 * pix1[0] + f2 * pix2[0] + f3 * pix3[0];
			green = f0 * pix0[1] + f1 * pix1[1] + f2 * pix2[1] + f3 * pix3[1];
			blue =  f0 * pix0[2] + f1 * pix1[2] + f2 * pix2[2] + f3 * pix3[2];

			/* avoid acolor in image     v.2.17 */
			if ( red == acolor && green == acolor && blue == acolor )
			{
				if ( blue == 0 ) blue = 1;
				else blue--;
			}

			/* output pixel */
			pix2 = ppix2 + py2 * rs2 + px2 * nch;
			pix2[0] = red;
			pix2[1] = green;
			pix2[2] = blue;
		}

	return pixbuf2;
}

/**
\brief
\author     Peter G Baum
\date
\note       From module parseoptions.c
\since      0.9.94
**/
static int getShortValue (
	Tcl_Interp *interp,
	Tcl_Obj *list,
	int idx,
	int *p )
{
	int val;
	Tcl_Obj *tp;

	if ( Tcl_ListObjIndex ( interp, list, idx, &tp ) != TCL_OK  )
		return TCL_ERROR;

	if ( Tcl_GetIntFromObj ( NULL, tp, &val ) != TCL_OK )
	{
		double d;

		if ( Tcl_GetDoubleFromObj ( NULL, tp, &d ) != TCL_OK )
		{
			Tcl_AppendResult ( interp,
							   "expected integer or double, but got \"",
							   Tcl_GetString ( tp ), "\"", NULL );
			return TCL_ERROR;
		}

		val = d * 0xFFFF;
	}

	if ( val < .0 || val > 0xFFFF )
	{
		Tcl_SetResult ( interp, "color value must be between 0 and 65535",
						TCL_STATIC );
		return TCL_ERROR;
	}

	*p = val;

	return TCL_OK;
}

/**
\brief
\author     Tadej Borov≈°ak
\date       14/Feb/2010
\note       gdk_color_parse() will only fill red, green and blue elements
             of GdkColor. In order to fill pixel value, you'll need to
             allocate your color using gdk_colormap_alloc_color().
             But event if you do this, pixel value is not what you want
             in this case, since pixel value is only meaningful in context
             of your underlying windowing system.

**/
static guint32 convertRGBtoPixel ( gchar *clr )
{

	GdkColor color;
	guint32 pixel;

	/* Conversion factor from 16-bit color to 8-bit color (0xff / 0xffff) */
	const gdouble f = 0.00389105;

	/* create the colour from the supplied string, added by WJG */
	gdk_color_parse ( clr, &color );

	/* fill with colour */
	pixel = ( ( ( guint ) ( color.red   * f + 0.5 ) ) << 24 ) | /* R */
			( ( ( guint ) ( color.green * f + 0.5 ) ) << 16 ) | /* G */
			( ( ( guint ) ( color.blue  * f + 0.5 ) ) <<  8 ) | /* B */
			( 0xff <<  0 );                                     /* A */

#ifdef DEBUG_PIXBUF
	printf ( "pixel = %d\n", pixel );
#endif
	return pixel;
}


/**
\brief
\author     Peter G Baum
\date
\note       From module parseoptions.c
\since      0.9.94
**/
static int getRGBA ( Tcl_Interp *interp, Tcl_Obj *obj, int *r, int *g, int *b, int *a )
{
	int no;

	if ( Tcl_ListObjLength ( interp, obj, &no ) != TCL_OK  || no < 0 || no > 4 )
	{
		Tcl_SetResult ( interp, "color must be either \"name\" or a list "
						"consisting of \"name alpha\", \"r g b\", or \"r g b alpha\"",
						TCL_STATIC );
		return TCL_ERROR;
	}

	if ( no == 0 ) /* transparent */
	{
		*r = *g = *b = *a = 0;
	}

	else if ( no < 3 )
	{
		Tcl_Obj *tp = obj;
		GdkColor color;

		if ( no == 2 )
		{
			if ( Tcl_ListObjIndex ( interp, obj, 0, &tp ) != TCL_OK )
				return TCL_ERROR;
		}

		/* take as string and reformat as a GdkColor structure */

		if ( gdk_color_parse ( Tcl_GetString ( tp ), &color ) == 0 )
		{
			Tcl_AppendResult ( interp, "unknown color \"", Tcl_GetString ( obj ), "\".", ( char * ) NULL );
			return TCL_ERROR;
		}

		*r = color.red;
		*g = color.green;
		*b = color.blue;

		if ( no == 2 )
		{
			if ( getShortValue ( interp, obj, 1, a ) != TCL_OK )
				return TCL_ERROR;
		}

		else
			*a = 0xFFFF;
	}

	else
	{
		if ( getShortValue ( interp, obj, 0, r ) != TCL_OK
				|| getShortValue ( interp, obj, 1, g ) != TCL_OK
				|| getShortValue ( interp, obj, 2, b ) != TCL_OK )
			return TCL_ERROR;

		if ( no == 4 )
		{
			if ( getShortValue ( interp, obj, 3, a ) != TCL_OK )
				return TCL_ERROR;
		}

		else
			*a = 0xFFFF;
	}

	return TCL_OK;
}

/**
\brief      Take colour values from a string format and assign them to
             location addressed by pointer *color.
\author     Peter G baum
\date
\note       From module parseoptions.c
\since      0.9.94
**/
static int getGdkColor ( Tcl_Interp *interp, Tcl_Obj *obj, GdkColor *color )
{
	int r, g, b, a;

	if ( getRGBA ( interp, obj, &r, &g, &b, &a ) != TCL_OK )
	{
		return TCL_ERROR;
	}

	/* TODO? if a != 0xFFFF: alpha not supported? */
	color->red = r;

	color->green = g;

	color->blue = b;

	return TCL_OK;
}

/**
\brief      Function associated with the pixbufs.
\author     William J Giddings
\date       12-Feb-09
\since      0.9.94
**/
int pixBufFunc ( ClientData data, Tcl_Interp *interp, int objc, Tcl_Obj * const objv[] )
{
	GdkPixbuf *pixbuf;

	pixbuf = GDK_PIXBUF ( data );

#ifdef DEBUG_PIXBUF
	g_printf ( "pixBufFunc\n" );
	gint _i;

	for ( _i = 0; _i < objc; _i++ )
	{
		g_printf ( "\targ %d = %s\n", _i,  Tcl_GetString ( objv[_i] ) );
	}

#endif


	static const char *cmds[] =
	{
		"copy", "delete", "configure", "duplicate",
		"cget", "draw", "class",
		"fill", "save", "turn",
		"flip", "rotate", "composite",
		"circle", "subpixuf", "cairo_1",
		"saturation", "pixelate", "colorize",
		"getPixel", "setPixel", "info", "filter",
		NULL
	};

	enum cmdIdx
	{
		CopyIdx, DeleteIdx, ConfigureIdx, DuplicateIdx,
		CgetIdx, DrawIdx, ClassIdx,
		FillIdx, SaveIdx, TurnIdx,
		FlipIdx, RotateIdx, CompositeIdx,
		CircleIdx, SubPixBufIdx, Cairo_1Idx,
		SaturationIdx, PixelateIdx, ColorizeIdx,
		GetPixelIdx, SetPixelIdx, InfoIdx, FilterIdx,
	};

	int idx;

	if ( objc < 2 )
	{
		Tcl_WrongNumArgs ( interp, 1, objv, "command" );
		return TCL_ERROR;
	}

	if ( Tcl_GetIndexFromObj ( interp, objv[1], cmds, "command", TCL_EXACT, &idx ) != TCL_OK )
	{
		return TCL_ERROR;
	}

	switch ( idx )
	{
		case DuplicateIdx:
			{
				GdkPixbuf *dest_pixbuf;
				dest_pixbuf = gdk_pixbuf_copy ( pixbuf );
				return gnoclRegisterPixBuf ( interp, dest_pixbuf, pixBufFunc );
			}
			break;
		case FilterIdx:
			{
				gnoclPixBufFilters ( GDK_PIXBUF ( pixbuf ), interp, objc, objv );
			}
			break;
		case InfoIdx:
			{
				gchar str[32];
				gint w, h, a, bps, n;
				w = gdk_pixbuf_get_width ( pixbuf );
				h = gdk_pixbuf_get_height ( pixbuf );
				a = gdk_pixbuf_get_has_alpha ( pixbuf );
				bps = gdk_pixbuf_get_bits_per_sample ( pixbuf );
				n = gdk_pixbuf_get_n_channels ( pixbuf );

				sprintf ( str, "%d %d %d %d %d", w, h, a, bps, n );

				Tcl_SetResult ( interp, str, TCL_STATIC );

			}
			break;
		case SetPixelIdx:
			{

				gint x;
				gint y;

				gint w;
				gint h;

				guchar r;
				guchar g;
				guchar b;
				guchar a;

				/* set pixel location */
				sscanf ( Tcl_GetString ( objv[2] ), "%d %d", &x, &y );
				sscanf ( Tcl_GetString ( objv[3] ),  &r, &g, &b , &a );


				w = gdk_pixbuf_get_width ( pixbuf );
				h = gdk_pixbuf_get_height ( pixbuf );

				if ( 0 )
				{
					GdkColor color;

					if ( getGdkColor ( interp, Tcl_GetString ( objv[3] ), &color ) != TCL_OK )
					{
						return TCL_ERROR;
					}
				}

				//set_pixel_color ( pixbuf, x, y , r, g, b, a );
#ifdef DEBUG_PIXBUF
				g_printf ( "x =%d y =%d w =%d h =%d\n", x, y, w, h );
				g_printf ( "r =%d g =%d b =%d a =%d\n", r, g, b, a );
#endif

				/* error checking */
				if ( x < 0 || x > gdk_pixbuf_get_width ( pixbuf )  )
				{
					//   return FALSE;
				}

				if ( y < 0 || y > gdk_pixbuf_get_height ( pixbuf )  )
				{
					//  return FALSE;
				}

				gdk_pixbuf_set_pixel ( pixbuf, convertRGBtoPixel ( Tcl_GetString ( objv[3] ) ), x, y );


			}
			break;

		case GetPixelIdx:
			{

				gint x;
				gint y;

				guchar r;
				guchar g;
				guchar b;
				guchar a;

				double R, G, B, A;

				gchar str[24];

				/* get pixel location */
				sscanf ( Tcl_GetString ( objv[2] ), "%d %d", &x, &y );
#ifdef DEBUG_PIXBUF
				g_printf ( "pos = %d %d\n", x, y );
#endif
				gdk_pixbuf_get_pixel ( pixbuf, x, y , &r, &g, &b, &a );


				/* convert int to decimal float */

				R = ( double ) r / 255;
				G = ( double ) g / 255;
				B = ( double ) b / 255;
				A = ( double ) a / 255;

				sprintf ( str, "%f %f %f %f", R, G, B, A );

				Tcl_SetResult ( interp, str, TCL_STATIC );

			}
			break;
		case PixelateIdx:
			{
				GdkPixbuf *dest_pixbuf;
				double saturation;

				/* simplest way to get the a duplicate buffer to paste into */
				dest_pixbuf = gdk_pixbuf_copy ( pixbuf );

				if ( 0 )
				{
					if ( Tcl_GetDoubleFromObj ( interp, objv[2], &saturation ) != TCL_OK )
					{
						Tcl_SetResult ( interp, "Invalid value set for saturation, must be a float.\n", TCL_STATIC );
						return TCL_ERROR;
					}
				}

				gdk_pixbuf_saturate_and_pixelate ( pixbuf, dest_pixbuf, 1.0, TRUE );

				return gnoclRegisterPixBuf ( interp, dest_pixbuf, pixBufFunc );
			}
			break;
		case SaturationIdx:
			{

				GdkPixbuf *dest_pixbuf;
				double saturation;

				/* simplest way to get the a duplicate buffer to paste into */
				dest_pixbuf = gdk_pixbuf_copy ( pixbuf );

				if ( Tcl_GetDoubleFromObj ( interp, objv[2], &saturation ) != TCL_OK )
				{
					Tcl_SetResult ( interp, "Invalid value set for saturation, must be a float.\n", TCL_STATIC );
					return TCL_ERROR;
				}

				gdk_pixbuf_saturate_and_pixelate ( pixbuf, dest_pixbuf, saturation, FALSE );

				return gnoclRegisterPixBuf ( interp, dest_pixbuf, pixBufFunc );

			}
			break;
		case CopyIdx:
			{
#ifdef DEBUG_PIXBUF
				g_print ( "CopyIdx %s\n", Tcl_GetString ( objv[2] ) );
#endif

				int src_x;
				int src_y;
				int width;
				int height;
				GdkPixbuf *dest_pixbuf;

				dest_pixbuf = gdk_pixbuf_new ( GDK_COLORSPACE_RGB, FALSE, 8, width, height );

				/* if no string is passed make a simple duplicate */
				if ( objc == 2 )
				{
#ifdef DEBUG_PIXBUF
					g_print ( "total args %d\n", objc );
#endif
					dest_pixbuf = gdk_pixbuf_copy ( pixbuf );
				}

				/* copy as specific region of the pixbuf */
				else
				{

					sscanf ( Tcl_GetString ( objv[2] ), "%d %d %d %d", &src_x, &src_y, &width, &height );
#ifdef DEBUG_PIXBUF
					g_print ( "CopyIdx %d %d %d %d\n", src_x, src_y, width, height );
#endif

					dest_pixbuf = gdk_pixbuf_new ( GDK_COLORSPACE_RGB, FALSE, 8, width, height );

					gdk_pixbuf_copy_area ( pixbuf, src_x, src_y, width, height, dest_pixbuf, 0, 0 );
				}

				return gnoclRegisterPixBuf ( interp, dest_pixbuf, pixBufFunc );

			}
			break;
		case SubPixBufIdx :
			{

				int src_x;
				int src_y;
				int width;
				int height;

				GdkPixbuf *dest_pixbuf;
				gint i;

				if ( sscanf ( Tcl_GetString ( objv[2] ), "%d %d %d %d", &src_x, &src_y, &width, &height ) != 4 )
				{
					Tcl_SetResult ( interp, "Should be: pixBuf-id subpixBuf {x y w h}./n", TCL_STATIC );

					return TCL_ERROR;
				}

				dest_pixbuf = gdk_pixbuf_new_subpixbuf ( pixbuf, src_x, src_y, width, height );

				return gnoclRegisterPixBuf ( interp, dest_pixbuf, pixBufFunc );
			}
			break;
		case DeleteIdx:
			{
			}
			break;
		case ConfigureIdx:
			{
			}
			break;
		case CgetIdx:
			{

				static char *cgetOptions[] =
				{
					"-colorSpace", "-nChannels", "-hasAlpha",
					"-bitsPerSample", "-pixels", "-width",
					"-height", "-rowstride", "-key",
					NULL
				};

				static enum  optsIdx
				{
					ColorSpaceIdx, NChannelsIdx, HasAlphaIdx,
					BitsPerSampleIdx, PixelsIdx, WidthIdx,
					HeightIdx, RowStrideIdx, KeyIdx
				};

				int Idx;

				if ( Tcl_GetIndexFromObj ( interp, objv[2], cgetOptions, "option", TCL_EXACT, &Idx ) != TCL_OK )
				{
					return TCL_ERROR;
				}

				switch ( Idx )
				{
					case ColorSpaceIdx:
						{

							/* 05/03/10 only RGB supported */
							gchar *str;

							switch ( gdk_pixbuf_get_colorspace ( pixbuf ) )
							{
								case GDK_COLORSPACE_RGB:
									{
										str = "RGB";
									}
									break;
							}

							Tcl_SetObjResult ( interp, Tcl_NewStringObj ( str, -1  ) );

						} break;
					case NChannelsIdx:
						{
							Tcl_SetObjResult ( interp, Tcl_NewIntObj ( gdk_pixbuf_get_bits_per_sample ( pixbuf ) ) );
						} break;
					case HasAlphaIdx:
						{
							Tcl_SetObjResult ( interp, Tcl_NewIntObj ( gdk_pixbuf_get_has_alpha ( pixbuf ) ) );
						} break;
					case BitsPerSampleIdx:
						{
							Tcl_SetObjResult ( interp, Tcl_NewIntObj ( gdk_pixbuf_get_bits_per_sample ( pixbuf ) ) );
						} break;
					case PixelsIdx:
						{
							/* Not terribly certain what this function implies */
							guchar *str;
							str = gdk_pixbuf_get_pixels ( pixbuf );

							Tcl_SetObjResult ( interp, Tcl_NewStringObj ( str, -1 ) );
						} break;
					case WidthIdx:
						{
							Tcl_SetObjResult ( interp, Tcl_NewIntObj ( gdk_pixbuf_get_width ( pixbuf ) ) );
						} break;
					case HeightIdx:
						{
							Tcl_SetObjResult ( interp, Tcl_NewIntObj ( gdk_pixbuf_get_height ( pixbuf ) ) );
						} break;
					case RowStrideIdx:
						{
							Tcl_SetObjResult ( interp, Tcl_NewIntObj ( gdk_pixbuf_get_rowstride ( pixbuf ) ) );
						} break;
					case KeyIdx:
						{
//const gchar * gdk_pixbuf_get_option (GdkPixbuf *pixbuf,const gchar *key);
						}
						break;
				}
			}
			break;
		case ClassIdx:
			{
				Tcl_SetObjResult ( interp, Tcl_NewStringObj ( "pixbuf", -1 ) );
			}
			break;
		case FillIdx:
			{
				gdk_pixbuf_fill ( pixbuf, convertRGBtoPixel ( Tcl_GetString ( objv[2] ) ) );

			}
			break;
		case SaveIdx:
			{
				GError *err;
				gchar *opt, *val;
				gchar *fileType;
				gchar *fileName;
				gchar *parameters;


				/* set a default filetype */
				fileType = NULL;
				fileName = NULL;
				parameters = NULL;

				static char *newOptions[] =
				{
					"-fileName", "-fileType", "-parameters",
					NULL
				};

				static enum  optsIdx
				{
					FileNameIdx, FileTypeIdx, ParametersIdx
				};

				gint i, j;
				int idx;

				for ( i = 2; i < objc; i += 2 )
				{
					j = i + 1;

					opt = Tcl_GetString ( objv[i] );
					val = Tcl_GetString ( objv[j] );


					if ( Tcl_GetIndexFromObj ( interp, objv[i], newOptions, "command", TCL_EXACT, &idx ) != TCL_OK )
					{
						return TCL_ERROR;
					}


					switch ( idx )
					{
						case FileNameIdx:
							{
								//g_printf ( "save file = %s val = %s\n", opt, val );
								err = NULL;
								fileName = val;

								if ( err != NULL )
								{
									g_warning ( err->message );
									g_error_free ( err );
								}
							}
							break;
						case FileTypeIdx:
							{

								GSList *p;

								//g_printf ( "file type = %s val = %s\n", opt, val );


								for ( p = gdk_pixbuf_get_formats (); p != NULL; p = p->next )
								{
									//g_printf ( "p = %s\n", gdk_pixbuf_format_get_name ( p->data ) );

									if ( !strcmp ( val, gdk_pixbuf_format_get_name ( p->data ) ) )
									{
										//g_printf ( "ok an acceptable format!\n" );
										fileType = val;
										break;

									}
								}

								if ( fileType == NULL )
								{
									gchar str[64];
									sprintf ( str, "GNOCL ERROR: \"%s\" is not a supported file format.\n", val );
									Tcl_SetResult ( interp, str, TCL_STATIC );
									return TCL_ERROR;
								}

							}
							break;
						case ParametersIdx:
							{
								parameters = val;
							}
							break;
						default:
							{
							}
					}
				}

				//g_printf ( "parameters = %s\n", parameters );


				if ( parameters == NULL )
				{
					gdk_pixbuf_save ( pixbuf, fileName, fileType, &err, NULL ) ;
					break;
				}


				/* handle any received parameters */
				if ( parameters != NULL )
				{

					gchar **tmp_array, **iterator;
					gchar *props[10], *vals[10];
					gint  k;


					tmp_array = g_strsplit_set ( parameters, "= ", 0 );
					iterator = tmp_array;
					i = 0;

					/* do the actual split */
					while ( i < g_strv_length ( tmp_array ) / 2 )
					{

						props[i] = *iterator;
						iterator++;

						vals[i]  = *iterator;
						iterator++;

						i++;
					}

					props[i] = NULL; /* First array needs to be NULL terminated */

					gdk_pixbuf_savev ( pixbuf, fileName, fileType, props, vals, NULL );
					g_strfreev ( tmp_array );

				}

				else
				{
					/* "plain" save if no parameters set */
					gdk_pixbuf_save ( pixbuf, fileName, fileType, &err, NULL );
				}

			} break;
		case TurnIdx:
			{
				/*
				typedef enum {
				    GDK_PIXBUF_ROTATE_NONE             =   0,
				    GDK_PIXBUF_ROTATE_COUNTERCLOCKWISE =  90,
				    GDK_PIXBUF_ROTATE_UPSIDEDOWN       = 180,
				    GDK_PIXBUF_ROTATE_CLOCKWISE        = 270
				} GdkPixbufRotation;
				*/


				int idx;
				int angle;

				angle = 0;

				static char *turnOptions[] =
				{
					"clockwise", "90",
					"counterClockwise", "antiClockwise", "270", "-90",
					"upsideDown", "180", "-180",
					NULL
				};

				static enum  optsIdx
				{
					ClockWiseIdx, _90Idx,
					CounterClockwiseIdx, AntiClockwiseIdx, _270Idx, _minus90Idx,
					UpsideDownIdx, _180Idx, _minus180Idx
				};

				if ( Tcl_GetIndexFromObj ( interp, objv[2], turnOptions, "command", TCL_EXACT, &idx ) != TCL_OK )
				{
					return TCL_ERROR;
				}

				switch ( idx )
				{
					case ClockWiseIdx:
					case _90Idx:
						{
							angle = 90;
						}
						break;

					case CounterClockwiseIdx:
					case AntiClockwiseIdx:
					case _270Idx:
					case _minus90Idx:
						{
							angle = 270;
						}

					case UpsideDownIdx:
					case _180Idx:
					case _minus180Idx:
						{
							angle = 180;
						}
						break;
				}


				/* get rotated copy of the buffer */
				GdkPixbuf *pb;
				pb = gdk_pixbuf_rotate_simple ( pixbuf, angle );

				/* clear the parent buffer, then copy accross with composite  */
				gdk_pixbuf_fill ( pixbuf, 0x000000000000 );
				gdk_pixbuf_composite ( pb, pixbuf, 0, 0,
									   gdk_pixbuf_get_width ( pixbuf ),
									   gdk_pixbuf_get_height ( pixbuf ),
									   0, 0, 1, 1,
									   GDK_INTERP_BILINEAR, 255 );
				/* free the intermediary pixbuf*/
				g_object_unref ( pb );
			}
			break;
		case FlipIdx:
			{
				GdkPixbuf *pb;

				/* horizontal */
				pb = gdk_pixbuf_flip ( pixbuf, TRUE );
				/* vertical */
				pb = gdk_pixbuf_flip ( pixbuf, FALSE );

				/* clear the parent buffer, then copy accross with composite  */
				gdk_pixbuf_fill ( pixbuf, 0x000000000000 );
				gdk_pixbuf_composite ( pb, pixbuf, 0, 0,
									   gdk_pixbuf_get_width ( pixbuf ),
									   gdk_pixbuf_get_height ( pixbuf ),
									   0, 0, 1, 1,
									   GDK_INTERP_BILINEAR, 255 );
				/* free the intermediary pixbuf*/
				g_object_unref ( pb );

			}
			break;
		case RotateIdx:
			{
				/* todo:
				   associate the named object with the new buffer which will be enlarged.
				   error check, this will not work on svg files
				*/
				GdkPixbuf *pb;
				gdouble angle;
				int acolor;
				gchar *name;

				acolor = 255 ; /* default is black */

				name = gnoclGetNameFromPixBuf ( data );

				Tcl_GetDoubleFromObj ( NULL, objv[3], &angle );

				/* only one option */
				if ( !strcmp ( Tcl_GetString ( objv[4] ), "-backgroundColor" ) )
				{

					acolor = Tcl_GetIntFromObj ( NULL, objv[5], &acolor ) ;
				}

				else
				{

					Tcl_SetResult ( interp, "Unknown option. M\n", TCL_STATIC );
					return TCL_ERROR;
				}


#ifdef DEBUG_PIXBUF
				g_print ( "Rotate 2 %s %f %s %d\n",
						  name ,
						  angle,
						  Tcl_GetString ( objv[5] ),
						  acolor ); // works ok!
#endif
				/* replace the current buffer with the new buffer */
				pb = pixbufRotate ( pixbuf, angle, acolor );

				if ( pb == NULL )
				{
					Tcl_SetResult ( interp, "Unable to create pixBuff\n", TCL_STATIC );
					return TCL_ERROR;
				}

				return gnoclRegisterPixBuf ( interp, pb, pixBufFunc );

			}
			break;
		case CompositeIdx:
			{
				/* this will clearly need parameters sorted from outset */
#ifdef DEBUG_PIXBUF
				gint _i;

				for ( _i = 2; _i < objc; _i++ )
				{
					g_printf ( "CompositeIdx \targ %d = %s\n", _i,  Tcl_GetString ( objv[_i] ) );
				}

#endif

				GdkPixbuf *src, *dest;
				gint dest_x, dest_y;
				gint dest_width, dest_height;
				gdouble offset_x, offset_y;
				gdouble scale_x, scale_y;
				GdkInterpType interp_type;
				gint overall_alpha;


				src = gnoclGetPixBufFromName ( Tcl_GetString ( objv[2] ), interp );
				dest = pixbuf;

				/* set some defaults */
				dest_x = 0;
				dest_y = 0;
				dest_width = gdk_pixbuf_get_width ( src );
				dest_height = gdk_pixbuf_get_height ( src );

				offset_x = 0;
				offset_y = 0;
				scale_x = 1;
				scale_y = 1;
				interp_type = GDK_INTERP_BILINEAR;
				overall_alpha = 255;

				/* reset values based upon received switches */

				gdk_pixbuf_composite ( src, dest,
									   dest_x, dest_y,
									   dest_width, dest_height,
									   offset_x, offset_y,
									   scale_x, scale_y,
									   interp_type, overall_alpha );

			}
			break;
		case CircleIdx:
			{
#ifdef DEBUG_PIXBUF
				g_printf ( "CircleIdx 1\n" );
#endif
				cairo_t *cr;

				cr = pixbuf_cairo_create ( pixbuf );
#ifdef DEBUG_PIXBUF
				g_printf ( "CircleIdx 2\n" );
#endif
				double x = 25.6,  y = 128.0;
				double x1 = 102.4, y1 = 230.4,
										x2 = 153.6, y2 = 25.6,
														 x3 = 230.4, y3 = 128.0;

				cairo_move_to ( cr, x, y );
				cairo_curve_to ( cr, x1, y1, x2, y2, x3, y3 );

				cairo_set_line_width ( cr, 10.0 );
				cairo_stroke ( cr );

				cairo_set_source_rgba ( cr, 1, 0.2, 0.2, 0.6 );
				cairo_set_line_width ( cr, 6.0 );
				cairo_move_to ( cr, x, y );   cairo_line_to ( cr, x1, y1 );
				cairo_move_to ( cr, x2, y2 ); cairo_line_to ( cr, x3, y3 );
				cairo_stroke ( cr );

				pixbuf_cairo_destroy ( cr, TRUE );

#ifdef DEBUG_PIXBUF
				g_printf ( "CircleIdx 3\n" );
#endif

				cairo_surface_write_to_png ( cr, "image.png" );
#ifdef DEBUG_PIXBUF
				g_printf ( "CircleIdx 4\n" );
#endif


			}
			break;
		case Cairo_1Idx:
			{
#ifdef DEBUG_PIXBUF
				g_printf ( "Cairo_1\n" );
#endif
				cairo_surface_t *surface;
				cairo_t *cr;

				surface = cairo_image_surface_create ( CAIRO_FORMAT_ARGB32, 390, 60 );
				cr = cairo_create ( surface );

				cairo_set_source_rgb ( cr, 0, 0, 0 );
				cairo_select_font_face ( cr, "Sans", CAIRO_FONT_SLANT_NORMAL,
										 CAIRO_FONT_WEIGHT_NORMAL );
				cairo_set_font_size ( cr, 40.0 );

				cairo_move_to ( cr, 10.0, 50.0 );
				cairo_show_text ( cr, "Gnocl 0.9.94" );

				cairo_surface_write_to_png ( surface, "image.png" );

				cairo_destroy ( cr );
				cairo_surface_destroy ( surface );


			}
			break;
		case DrawIdx:
			{
				/* draw the pixbuf to a GdkDrawable: ie. a drawing area */
				GtkWidget *widget;
				GdkDrawable *dest;
				gint src_x, src_y;
				gint dest_x, dest_y;
				gint width, height;
				gint x_dither, y_dither;

				/* initialize the values with defaults */
				src_x = 0;
				src_y = 0;
				dest_x = 10;
				dest_y = 10;

				x_dither = 0;
				y_dither = 0;

				/* what size of the buffer has to be drawn */
				width = gdk_pixbuf_get_width ( pixbuf );
				height = gdk_pixbuf_get_height ( pixbuf );

				widget = gnoclGetWidgetFromName ( Tcl_GetString ( objv[2] ), interp );

				if ( widget == NULL )
				{
					return TCL_ERROR;
				}

				dest = GDK_DRAWABLE ( widget->window );

				/* change values based upon switches passed */

				gdk_draw_pixbuf (
					dest,
					gdk_gc_new ( widget->window ),
					pixbuf,
					src_x, src_y,
					dest_x, dest_y,
					width,
					height,
					GDK_RGB_DITHER_NONE,
					x_dither, y_dither );

			}
			break;
	}

	return TCL_OK;
}


/**
\brief
\author     William J Giddings
\date       12-Feb-09
\since      0.9.94
\note      "char *" and not "const char *" because of a not very strict
            handling of "const char *" in Tcl e.g. Tcl_CreateObjCommand
*/


char *gnoclGetAutoPixBufId ( void )
{
	static int no = 0;
	/*
	static char buffer[30];
	*/

	char *buffer = g_new ( char, sizeof ( idPrefix ) + 15 );
	strcpy ( buffer, idPrefix );

	/* with namespace, since the Id is also the widget command */
	sprintf ( buffer + sizeof ( idPrefix ) - 1, "%d", ++no );

	return buffer;
}

/**
\brief
\author     William J Giddings, Peter G Baum
\date
\since      0.9.94
**/
/* -----------------
   handle widget <-> name mapping
-------------------- */
GdkPixbuf *gnoclGetPixBufFromName ( const char *id, Tcl_Interp *interp )
{
	GdkPixbuf *pixbuf = NULL;
	int       n;

	if ( strncmp ( id, idPrefix, sizeof ( idPrefix ) - 1 ) == 0
			&& ( n = atoi ( id + sizeof ( idPrefix ) - 1 ) ) > 0 )
	{
		pixbuf = g_hash_table_lookup ( name2pixbufList, GINT_TO_POINTER ( n ) );
	}

	if ( pixbuf == NULL && interp != NULL )
	{
		Tcl_AppendResult ( interp, "Unknown pixbuf \"", id, "\".", ( char * ) NULL );
	}

	return pixbuf;
}

/**
\brief      Returns the widget name associated with pointer
\author     Peter G Baum
\date
\since      0.9.94
**/
const char *gnoclGetNameFromPixBuf ( GdkPixbuf *pixbuf )
{
	const char *name = g_object_get_data ( G_OBJECT ( pixbuf ), "gnocl::name" );

	return name;
}




/**
\brief
\author Peter G Baum
\date
\since      0.9.94
**/
int gnoclForgetPixBufFromName ( const char *path )
{
	int n = atoi ( path + sizeof ( idPrefix ) - 1 );
	assert ( gnoclGetPixBufFromName ( path, NULL ) );
	assert ( strncmp ( path, idPrefix, sizeof ( idPrefix ) - 1 ) == 0 );
	assert ( n > 0 );

	g_hash_table_remove ( name2pixbufList, GINT_TO_POINTER ( n ) );

	return 0;
}

/**
\brief
\author     William J Giddings
\date       12-Feb-09
\since      0.9.94
**/
static void simpleDestroyFunc ( GdkPixbuf *pixbuf, gpointer data )
{
	const char *name = gnoclGetNameFromPixBuf ( pixbuf );
	gnoclForgetPixBufFromName ( name );
	Tcl_DeleteCommand ( ( Tcl_Interp * ) data, ( char * ) name );
	g_free ( ( char * ) name );
}


/**
\brief
\author     William J Giddings
\date       12-Feb-09
\since      0.9.94
**/
int gnoclMemNameAndPixBuf ( const char *path,  GdkPixbuf *pixbuf )
{


	int n ;

	n = atoi ( path + sizeof ( idPrefix ) - 1 );

	assert ( n > 0 );
	assert ( g_hash_table_lookup ( name2pixbufList, GINT_TO_POINTER ( n ) ) == NULL );
	assert ( strncmp ( path, idPrefix, sizeof ( idPrefix ) - 1 ) == 0 );

	/* memorize the name of the widget in the widget */
	g_object_set_data ( G_OBJECT ( pixbuf ), "gnocl::name", ( char * ) path );
	g_hash_table_insert ( name2pixbufList, GINT_TO_POINTER ( n ), pixbuf );

	return 0;
}

/**
\brief
\author    William J Giddings
\date
\since      0.9.94
**/
int gnoclRegisterPixBuf ( Tcl_Interp *interp, GdkPixbuf *pixbuf, Tcl_ObjCmdProc *proc )
{

	const char *name;

	name = gnoclGetAutoPixBufId();

	gnoclMemNameAndPixBuf ( name, pixbuf ); //<--- problems here

	//g_signal_connect_after ( G_OBJECT ( pixbuf ), "destroy", G_CALLBACK ( simpleDestroyFunc ), interp );

	if ( proc != NULL )
	{

		Tcl_CreateObjCommand ( interp, ( char * ) name, proc, pixbuf, NULL );
	}

	Tcl_SetObjResult ( interp, Tcl_NewStringObj ( name, -1 ) );

	return TCL_OK;
}

/**
\brief      Convert colour to hexadecimal.
\author     William J Giddings
\date       19/03/2010
\since      0.9.94g
**/
int gnoclRGB2HexCmd ( ClientData data, Tcl_Interp *interp, int objc, Tcl_Obj * const objv[] )
{

#ifdef DEBUG_PIXBUF
	g_printf ( "gnoclRGB2HexCmd\n" );
	gint _i;


	for ( _i = 0; _i < objc; _i++ )
	{
		g_printf ( "\targ %d = %s\n", _i,  Tcl_GetString ( objv[_i] ) );
	}

#endif

	GdkColor color;
	gchar str[25];
	gint val;

	getGdkColor ( interp, objv[1], &color );
	sprintf ( str, "#%.2x%.2x%.2x", color.red, color.green, color.blue );

	/* differentiate between 8 / 16 bit colour */
	if ( strcmp ( Tcl_GetString ( objv[2] ), "-8bit" ) == 0 )
	{
		Tcl_GetIntFromObj ( NULL, objv[3], &val );

		/* value of 0 means 16-bit */
		if ( !val )
		{
			color.red *= 257;
			color.green *= 257;
			color.blue *= 257;
			sprintf ( str, "#%.4x%.4x%.4x", color.red, color.green, color.blue );
		}

	}


	Tcl_SetObjResult ( interp, Tcl_NewStringObj ( &str, -1 ) ) ;

	return TCL_OK;
}

/**
\brief      Convert colour 16-bit RGB decimal.
\author     William J Giddings
\date       19/03/2010
\since      0.9.94g
**/
int gnoclClr2RGBCmd ( ClientData data, Tcl_Interp *interp, int objc, Tcl_Obj * const objv[] )
{

#ifdef DEBUG_PIXBUF
	g_printf ( "gnoclClr2RGBCmd\n" );
	gint _i;


	for ( _i = 0; _i < objc; _i++ )
	{
		g_printf ( "\targ %d = %s\n", _i,  Tcl_GetString ( objv[_i] ) );
	}

#endif

	GdkColor color;
	gchar str[25];
	gint val;

	getGdkColor ( interp, objv[1], &color );

	/* differentiate between 8 / 16 bit colour */
	if ( strcmp ( Tcl_GetString ( objv[2] ), "-8bit" ) == 0 )
	{
		Tcl_GetIntFromObj ( NULL, objv[3], &val );

		if ( !val )
		{

			color.red *= 257;
			color.green *= 257;
			color.blue *= 257;
		}

	}

	sprintf ( str, "%d %d %d", color.red, color.green, color.blue );
	Tcl_SetObjResult ( interp, Tcl_NewStringObj ( &str, -1 ) ) ;

	return TCL_OK;
}


/**
\brief
\author     William J Giddings
\date       17-Jan-2010
\since      0.9.94
**/
int gnoclPixBufCmd ( ClientData data, Tcl_Interp *interp, int objc, Tcl_Obj * const objv[] )
{

	/* create new hash table if one does not exist */
	if ( name2pixbufList == NULL )
	{
		name2pixbufList = g_hash_table_new ( g_direct_hash, g_direct_equal );
	}

#ifdef DEBUG_PIXBUF
	g_printf ( "gnoclpixBufCmd\n" );
	gint _i;

	for ( _i = 0; _i < objc; _i++ )
	{
		g_printf ( "\targ %d = %s\n", _i,  Tcl_GetString ( objv[_i] ) );
	}

#endif

	static const char *cmd[] =
	{
		"get", "render", "types",
		"description", "license", "licence",
		"extensions", "scalable", "writable",
		"fileInfo", "new", "load",
		NULL
	};

	enum cmdIdx
	{
		GetIdx, RenderIdx, TypesIdx,
		DescriptionIdx, LicenseIdx, LicenceIdx,
		ExtensionsIdx, ScalableIdx, WritableIdx,
		FileInfoIdx, NewIdx, LoadIdx
	};

	int cIdx;

	/* set relevant options for commands / sub-commands */
	const int opt1Idx = 0;
	const int opt2Idx = 1;
	const int opt3Idx = 2;

	GnoclOption cmd2Options[] =
	{
		{ "-option1", GNOCL_STRING, "", NULL},
		{ "-option2", GNOCL_STRING, "", NULL },
		{ "-option3", GNOCL_STRING, "", NULL },
		{ NULL }
	};

	/* must have the form <command-name> action objectName <options> */
	if ( objc <= 1 )
	{
		Tcl_WrongNumArgs ( interp, 1, objv, "command option... " );
		return TCL_ERROR;
	}

	if ( Tcl_GetIndexFromObj ( interp, objv[1], cmd, "option", TCL_EXACT, &cIdx ) != TCL_OK )
	{
		return TCL_ERROR;
	}

	switch ( cIdx )
	{
			/* implement template with subcommands and */
		case GetIdx:
			{
				static const char *subCmd[] = { "drawable", "image", "subCmd3", NULL };
				enum subCmdtIdx { DrawableIdx, ImageIdx, SubCmd3Idx };
				int scIdx;
				Tcl_Obj *tp;

				if ( Tcl_GetIndexFromObj ( interp, objv[2], subCmd, "option", TCL_EXACT, &scIdx ) != TCL_OK )
				{
					return TCL_ERROR;
				}

				if ( objc != 4 )
				{
					return TCL_ERROR;
				}


				switch ( scIdx )
				{
					case ImageIdx:
					case DrawableIdx:
						{

							/* create a new buffer from the buffer associated with a specific drawable object
							   only works for object already rendered to screen
							*/

							GtkWidget *widget;
							widget = gnoclGetWidgetFromName ( Tcl_GetString ( objv[3] ), interp  );

							if ( widget == NULL )
							{
								//widget = gnoclGetPixMapFromName ( Tcl_GetString ( objv[3] ), interp  );
								//if (widget == NULL) {
								return TCL_ERROR;
								//}
							}

							int x, y, width, height, depth;
							GdkPixbuf *pixbuf;

							gdk_window_get_geometry (
								widget->window ,
								&x, &y,
								&width, &height,
								&depth );


							pixbuf = gdk_pixbuf_get_from_drawable (
										 NULL,
										 GDK_DRAWABLE ( widget->window ),
										 NULL,
										 0, 0,
										 0, 0,
										 width, height );


							/* register the new item */
							return gnoclRegisterPixBuf ( interp, pixbuf, pixBufFunc );

						}
						break;

					case SubCmd3Idx:
						{
							g_printf ( "\topt1 subCmd3 %s\n", Tcl_GetString ( objv[3] ) );
						}
						break;
				}
			}
			break;
		case RenderIdx:
			{
				/* set relevant options for commands / sub-commands */
				static char *cmd2Options[] = { "-option1", "-option2", "-option3",  NULL};
				static enum  optsIdx { opt1Idx, opt2Idx, opt3Idx };

				/* this one has the options usage:
				    gnocl::<CmdName> command item -option val..
				*/
				int ret;

				ret = compare ( Tcl_GetString ( objv[2] ), cmd2Options );

				switch ( ret )
				{
					case opt1Idx:
						{
							g_printf ( "\t\toption1, parameters = %s\n", Tcl_GetString ( objv[3] ) );
						}
						break;
					case opt2Idx:
						{
							g_printf ( "\t\toption2, parameters = %s\n", Tcl_GetString ( objv[3] ) );
						}
						break;
					case opt3Idx:
						{
							g_printf ( "\t\toption3, parameters = %s\n", Tcl_GetString ( objv[3] ) );
						}
						break;
				}

			}
			break;
		case TypesIdx:
			{
				Tcl_Obj *resList;

				resList = Tcl_NewListObj ( 0, NULL );

				GSList *p;

				for ( p = gdk_pixbuf_get_formats (); p != NULL; p = p->next )
				{

					Tcl_ListObjAppendElement ( interp, resList,
											   Tcl_NewStringObj ( gdk_pixbuf_format_get_name ( p->data ), -1 ) );

				}

				g_free ( p );
				Tcl_SetObjResult ( interp, resList );
			}
			break;
		case DescriptionIdx:
			{
				Tcl_Obj *resList;

				resList = Tcl_NewListObj ( 0, NULL );
				GSList *p;

				for ( p = gdk_pixbuf_get_formats (); p != NULL; p = p->next )
				{
					if ( !strcmp ( gdk_pixbuf_format_get_name ( p->data ), Tcl_GetString ( objv[2] ) ) )
					{
						Tcl_SetObjResult ( interp, Tcl_NewStringObj ( gdk_pixbuf_format_get_description ( p->data ), -1 ) );
					}
				}

				g_free ( p );


			}
			break;
		case LicenceIdx:
		case LicenseIdx:
			{
				Tcl_Obj *resList;

				resList = Tcl_NewListObj ( 0, NULL );
				GSList *p;

				for ( p = gdk_pixbuf_get_formats (); p != NULL; p = p->next )
				{
					if ( !strcmp ( gdk_pixbuf_format_get_name ( p->data ), Tcl_GetString ( objv[2] ) ) )
					{
						Tcl_SetObjResult ( interp, Tcl_NewStringObj ( gdk_pixbuf_format_get_license ( p->data ), -1 ) );
					}
				}

				g_free ( p );


			}
			break;
		case ExtensionsIdx:
			{
				gchar * extensions;
				gchar **extension_list;

				Tcl_Obj *resList;

				resList = Tcl_NewListObj ( 0, NULL );
				GSList *p;

				for ( p = gdk_pixbuf_get_formats (); p != NULL; p = p->next )
				{
					if ( !strcmp ( gdk_pixbuf_format_get_name ( p->data ), Tcl_GetString ( objv[2] ) ) )
					{

						extension_list = gdk_pixbuf_format_get_extensions ( p->data );
						extensions = g_strjoinv ( " ", extension_list );
						g_strfreev ( extension_list );

						Tcl_SetObjResult ( interp, Tcl_NewStringObj ( extensions, -1 ) );
					}
				}

				g_free ( p );


			}
			break;
		case ScalableIdx:
			{

				GSList *p;

				gint res = -1;

				for ( p = gdk_pixbuf_get_formats (); p != NULL; p = p->next )
				{
					if ( !strcmp ( gdk_pixbuf_format_get_name ( p->data ), Tcl_GetString ( objv[2] ) ) )
					{
						res = gdk_pixbuf_format_is_scalable ( p->data );
					}
				}

				g_free ( p );

				Tcl_SetObjResult ( interp, Tcl_NewIntObj ( res ) ) ;


			}
			break;
		case WritableIdx:
			{

				GSList *p;

				gint res = -1;

				for ( p = gdk_pixbuf_get_formats (); p != NULL; p = p->next )
				{
					if ( !strcmp ( gdk_pixbuf_format_get_name ( p->data ), Tcl_GetString ( objv[2] ) ) )
					{
						res = gdk_pixbuf_format_is_writable ( p->data );
					}
				}

				g_free ( p );

				Tcl_SetObjResult ( interp, Tcl_NewIntObj ( res ) ) ;
			}
			break;
		case FileInfoIdx:
			{

				GdkPixbufFormat *format;
				gint width;
				gint height;
				gchar str[128];

				format = gdk_pixbuf_get_file_info ( Tcl_GetString ( objv[2] ), &width, &height );

				sprintf ( str, "%d %d %s\n", width, height, gdk_pixbuf_format_get_name ( format ) );

				Tcl_SetObjResult ( interp, Tcl_NewStringObj ( &str, -1 ) ) ;

			}
			break;
		case NewIdx:
			{
				GdkPixbuf *pixbuf;
				gchar *name;

				gint width, height, bps, alpha;
				gchar *opt, *val;
				gint clrspace;

				/* set some default values, then re-assign based upon received values */
				width = 640;
				height = 480;
				bps = 8;
				alpha = 0;
				clrspace = GDK_COLORSPACE_RGB;

				static char *newOptions[] =
				{
					"-width", "-height", "-bitsPerSample", "-colorSpace",
					"-alpha", "-name", "-data",
					NULL
				};

				static enum  optsIdx
				{
					WidthIdx, HeightIdx,
					BitsPerSampleIdx, ColorSpaceIdx,
					AlphaIdx, NameIdx, DataIdx
				};

				gint i, j;
				int idx;

				/* create the buffer,note: only RGB suported */
				//sscanf ( Tcl_GetString ( objv[2] ), "%d %d %d", &width, &height, &bps );
				//pixbuf = gdk_pixbuf_new ( GDK_COLORSPACE_RGB, alpha, bps, width, height );

				/* parse remaining the switches */
				/* set relevant options for commands / sub-commands */

				for ( i = 2; i < objc; i += 2 )
				{
					j = i + 1;

					opt = Tcl_GetString ( objv[i] );
					val = Tcl_GetString ( objv[j] );

					if ( Tcl_GetIndexFromObj ( interp, objv[i], newOptions, "command", TCL_EXACT, &idx ) != TCL_OK )
					{
						return TCL_ERROR;
					}


					switch ( idx )
					{
						case ColorSpaceIdx:
							{
								g_printf ( "GNOCL WARNING: Currently only GDK_COLORSPACE_RGB supported, set by default.\n" );
							}
							break;
						case WidthIdx:
							{
								//g_printf ( "\t\toption1, parameters = %s val = %s\n", opt, val );
								Tcl_GetIntFromObj ( NULL, objv[j], &width );
							}
							break;
						case HeightIdx:
							{
								//g_printf ( "\t\toption1, parameters = %s val = %s\n", opt, val );
								Tcl_GetIntFromObj ( NULL, objv[j], &height );
							}
							break;
						case AlphaIdx:
							{
								//g_printf ( "\t\toption1, parameters = %s val = %s\n", opt, val );
								Tcl_GetIntFromObj ( NULL, objv[j], &alpha );

								if ( alpha != 0 )
								{
									alpha = 1;
								}
							}
							break;
						case BitsPerSampleIdx:
							{
								//g_printf ( "\t\toption1, parameters = %s val = %s\n", opt, val );
								Tcl_GetIntFromObj ( NULL, objv[j], &bps );
							} break;
						case NameIdx:
							{
								g_printf ( "%s Yet to be implemented.", val );
							}
							break;
						case DataIdx:
							{
								g_printf ( "%s Yet to be implemented.", val );;
							}
							break;
						default:
							{
								return TCL_ERROR;
							}
					}

				} /* end of switch parsing */

				pixbuf = gdk_pixbuf_new ( clrspace, alpha, bps, width, height );


				return gnoclRegisterPixBuf ( interp, pixbuf, pixBufFunc );
				//Tcl_SetObjResult ( interp, Tcl_NewStringObj ( name, -1 ) ) ;
			} break;
		case LoadIdx:
			{
				// GdkPixbuf * gdk_pixbuf_new_from_file (const char *filename, GError **error);
				GdkPixbuf *pixbuf;
				gchar *opt, *val;
				gchar *filename;


				static char *newOptions[] =
				{
					"-file", "-width", "-height", "-aspectRatio",
					NULL
				};

				static enum  optsIdx
				{
					FileIdx, WidthIdx, HeightIdx, AspectRatioIdx
				};

				gint i, j;
				int idx;

				/* set some default values */
				gint height = 0;
				gint width = 0;
				gint aspect = 1;

				for ( i = 2; i < objc; i += 2 )
				{
					j = i + 1;

					opt = Tcl_GetString ( objv[i] );
					val = Tcl_GetString ( objv[j] );


					if ( Tcl_GetIndexFromObj ( interp, objv[i], newOptions, "command", TCL_EXACT, &idx ) != TCL_OK )
					{
						return TCL_ERROR;
					}


					switch ( idx )
					{
						case HeightIdx:
							{
								height = atoi ( val );
							}
							break;
						case WidthIdx:
							{
								width = atoi ( val );
							}
							break;
						case FileIdx:
							{
								//g_printf ( "load file = %s val = %s\n", opt, val );
								//pixbuf = gdk_pixbuf_new_from_file ( val, NULL );
								filename = val;
							}
							break;
						case AspectRatioIdx:
							{
								/* need error check, its a boolean! */
								aspect = atoi ( val );
							}
							break;
						default:
							{
							}
					}
				}


				if ( height != 0 && width != 0 )
				{
					//printf ( "OK!! height = %d width = %d\n", height, width );
					pixbuf = gdk_pixbuf_new_from_file_at_scale ( filename, width, height, aspect, NULL );
				}

				else
				{
					//printf ( "NOPE!! height = %d width = %d\n", height, width );
					pixbuf = gdk_pixbuf_new_from_file ( val, NULL );
				}

				return gnoclRegisterPixBuf ( interp, pixbuf, pixBufFunc );
			}
			break;
	}

	return TCL_OK;
}

/* code supplied by Tadej */
/**
 * pixbuf_cairo_create:
 * @pixbuf: GdkPixbuf that you wish to wrap with cairo context
 *
 * This function will initialize new cairo context with contents of @pixbuf. You
 * can then draw using returned context. When finished drawing, you must call
 * pixbuf_cairo_destroy() or your pixbuf will not be updated with new contents!
 *
 * Return value: New cairo_t context. When you're done with it, call
 * pixbuf_cairo_destroy() to update your pixbuf and free memory.
 */

/* Key for automated pixbuf updating and destruction */
static const cairo_user_data_key_t pixbuf_key;

static cairo_t *
pixbuf_cairo_create ( GdkPixbuf *pixbuf )
{
	gint             width,        /* Width of both pixbuf and surface */
	height,       /* Height of both pixbuf and surface */
	p_stride,     /* Pixbuf stride value */
	p_n_channels, /* RGB -> 3, RGBA -> 4 */
	s_stride;     /* Surface stride value */
	guchar          *p_pixels,     /* Pixbuf's pixel data */
	*s_pixels;     /* Surface's pixel data */
	cairo_surface_t *surface;      /* Temporary image surface */
	cairo_t         *cr;           /* Final context */

	g_object_ref ( G_OBJECT ( pixbuf ) );

	/* Inspect input pixbuf and create compatible cairo surface */
	g_object_get ( G_OBJECT ( pixbuf ), "width",           &width,
				   "height",          &height,
				   "rowstride",       &p_stride,
				   "n-channels",      &p_n_channels,
				   "pixels",          &p_pixels,
				   NULL );
	surface = cairo_image_surface_create ( CAIRO_FORMAT_ARGB32, width, height );
	s_stride = cairo_image_surface_get_stride ( surface );
	s_pixels = cairo_image_surface_get_data ( surface );

	/* Copy pixel data from pixbuf to surface */
	while ( height-- )
	{
		gint    i;
		guchar *p_iter = p_pixels,
						 *s_iter = s_pixels;

		for ( i = 0; i < width; i++ )
		{
#if G_BYTE_ORDER == G_LITTLE_ENDIAN

			/* Pixbuf:  RGB(A)
			 * Surface: BGRA */
			if ( p_n_channels == 3 )
			{
				s_iter[0] = p_iter[2];
				s_iter[1] = p_iter[1];
				s_iter[2] = p_iter[0];
				s_iter[3] = 0xff;
			}

			else /* p_n_channels == 4 */
			{
				gdouble alpha_factor = p_iter[3] / ( gdouble ) 0xff;

				s_iter[0] = ( guchar ) ( p_iter[2] * alpha_factor + .5 );
				s_iter[1] = ( guchar ) ( p_iter[1] * alpha_factor + .5 );
				s_iter[2] = ( guchar ) ( p_iter[0] * alpha_factor + .5 );
				s_iter[3] =           p_iter[3];
			}

#elif G_BYTE_ORDER == G_BIG_ENDIAN

			/* Pixbuf:  RGB(A)
			 * Surface: ARGB */
			if ( p_n_channels == 3 )
			{
				s_iter[3] = p_iter[2];
				s_iter[2] = p_iter[1];
				s_iter[1] = p_iter[0];
				s_iter[0] = 0xff;
			}

			else /* p_n_channels == 4 */
			{
				gdouble alpha_factor = p_iter[3] / ( gdouble ) 0xff;

				s_iter[3] = ( guchar ) ( p_iter[2] * alpha_factor + .5 );
				s_iter[2] = ( guchar ) ( p_iter[1] * alpha_factor + .5 );
				s_iter[1] = ( guchar ) ( p_iter[0] * alpha_factor + .5 );
				s_iter[0] =           p_iter[3];
			}

#else /* PDP endianness */

			/* Pixbuf:  RGB(A)
			 * Surface: RABG */
			if ( p_n_channels == 3 )
			{
				s_iter[0] = p_iter[0];
				s_iter[1] = 0xff;
				s_iter[2] = p_iter[2];
				s_iter[3] = p_iter[1];
			}

			else /* p_n_channels == 4 */
			{
				gdouble alpha_factor = p_iter[3] / ( gdouble ) 0xff;

				s_iter[0] = ( guchar ) ( p_iter[0] * alpha_factor + .5 );
				s_iter[1] =           p_iter[3];
				s_iter[1] = ( guchar ) ( p_iter[2] * alpha_factor + .5 );
				s_iter[2] = ( guchar ) ( p_iter[1] * alpha_factor + .5 );
			}

#endif
			s_iter += 4;
			p_iter += p_n_channels;
		}

		s_pixels += s_stride;
		p_pixels += p_stride;
	}

	/* Create context and set user data */
	cr = cairo_create ( surface );
	cairo_surface_destroy ( surface );
	cairo_set_user_data ( cr, &pixbuf_key, pixbuf, g_object_unref );

	/* Return context */
	return ( cr );
}

/**
 * pixbuf_cairo_destroy:
 * @cr: Cairo context that you wish to destroy
 * @create_new_pixbuf: If TRUE, new pixbuf will be created and returned. If
 *                     FALSE, input pixbuf will be updated in place.
 *
 * This function will destroy cairo context, created with pixbuf_cairo_create().
 *
 * Return value: New or updated GdkPixbuf. You own a new reference on return
 * value, so you need to call g_object_unref() on returned pixbuf when you don't
 * need it anymore.
 */
static GdkPixbuf *
pixbuf_cairo_destroy ( cairo_t  *cr,
					   gboolean  create_new_pixbuf )
{
	gint             width,        /* Width of both pixbuf and surface */
	height,       /* Height of both pixbuf and surface */
	p_stride,     /* Pixbuf stride value */
	p_n_channels, /* RGB -> 3, RGBA -> 4 */
	s_stride;     /* Surface stride value */
	guchar          *p_pixels,     /* Pixbuf's pixel data */
	*s_pixels;     /* Surface's pixel data */
	cairo_surface_t *surface;      /* Temporary image surface */
	GdkPixbuf       *pixbuf,       /* Pixbuf to be returned */
	*tmp_pix;      /* Temporary storage */

	/* Obtain pixbuf to be returned */
	tmp_pix = cairo_get_user_data ( cr, &pixbuf_key );

	if ( create_new_pixbuf )
		pixbuf = gdk_pixbuf_copy ( tmp_pix );
	else
		pixbuf = g_object_ref ( G_OBJECT ( tmp_pix ) );

	/* Obtain surface from where pixel values will be copied */
	surface = cairo_get_target ( cr );

	/* Inspect pixbuf and surface */
	g_object_get ( G_OBJECT ( pixbuf ), "width",           &width,
				   "height",          &height,
				   "rowstride",       &p_stride,
				   "n-channels",      &p_n_channels,
				   "pixels",          &p_pixels,
				   NULL );
	s_stride = cairo_image_surface_get_stride ( surface );
	s_pixels = cairo_image_surface_get_data ( surface );

	/* Copy pixel data from surface to pixbuf */
	while ( height-- )
	{
		gint    i;
		guchar *p_iter = p_pixels,
						 *s_iter = s_pixels;

		for ( i = 0; i < width; i++ )
		{
#if G_BYTE_ORDER == G_LITTLE_ENDIAN
			/* Pixbuf:  RGB(A)
			 * Surface: BGRA */
			gdouble alpha_factor = ( gdouble ) 0xff / s_iter[3];

			p_iter[0] = ( guchar ) ( s_iter[2] * alpha_factor + .5 );
			p_iter[1] = ( guchar ) ( s_iter[1] * alpha_factor + .5 );
			p_iter[2] = ( guchar ) ( s_iter[0] * alpha_factor + .5 );

			if ( p_n_channels == 4 )
				p_iter[3] = s_iter[3];

#elif G_BYTE_ORDER == G_BIG_ENDIAN
			/* Pixbuf:  RGB(A)
			 * Surface: ARGB */
			gdouble alpha_factor = ( gdouble ) 0xff / s_iter[0];

			p_iter[0] = ( guchar ) ( s_iter[1] * alpha_factor + .5 );
			p_iter[1] = ( guchar ) ( s_iter[2] * alpha_factor + .5 );
			p_iter[2] = ( guchar ) ( s_iter[3] * alpha_factor + .5 );

			if ( p_n_channels == 4 )
				p_iter[3] = s_iter[0];

#else /* PDP endianness */
			/* Pixbuf:  RGB(A)
			 * Surface: RABG */
			gdouble alpha_factor = ( gdouble ) 0xff / s_iter[1];

			p_iter[0] = ( guchar ) ( s_iter[0] * alpha_factor + .5 );
			p_iter[1] = ( guchar ) ( s_iter[3] * alpha_factor + .5 );
			p_iter[2] = ( guchar ) ( s_iter[2] * alpha_factor + .5 );

			if ( p_n_channels == 4 )
				p_iter[3] = s_iter[1];

#endif
			s_iter += 4;
			p_iter += p_n_channels;
		}

		s_pixels += s_stride;
		p_pixels += p_stride;
	}

	/* Destroy context */
	cairo_destroy ( cr );

	/* Return pixbuf */
	return ( pixbuf );
}

/**
\brief      Obtain colour and alpha values from an RGBA pixBuf.
\author     William J Giddings
\date       06/03/10
\since      0.9.94
**/
void gdk_pixbuf_get_pixel ( GdkPixbuf *pixbuf, guint x, guint y , guchar *r, guchar *g, guchar *b, guchar *a )
{
	guchar *pixels;
	guchar *p;
	guint w, h;
	guint rowstride, n_channels;

	g_return_if_fail ( GDK_IS_PIXBUF ( pixbuf ) );

	w = gdk_pixbuf_get_width ( pixbuf );
	h = gdk_pixbuf_get_height ( pixbuf );

	if ( w == 0 || h == 0 )
	{
		return;
	}

	if ( x > w || y > h )
	{
		return;
	}

	pixels = gdk_pixbuf_get_pixels ( pixbuf );
	rowstride = gdk_pixbuf_get_rowstride ( pixbuf );
	n_channels = gdk_pixbuf_get_n_channels ( pixbuf );

	p = pixels + x * n_channels + y * rowstride;

	*r = p[0];
	*g = p[1];
	*b = p[2];
	*a = ( n_channels == 4 ) ? p[3] : 0;

}


/*---------------------------------------------------------------------*/

/**
 * gdk_pixbuf_fill:
 * @pixbuf: a #GdkPixbuf
 * @pixel: RGBA pixel to clear to
 *         (0xffffffff is opaque white, 0x00000000 transparent black)
 *
 * Clears a pixbuf to the given RGBA value, converting the RGBA value into
 * the pixbuf's pixel format. The alpha will be ignored if the pixbuf
 * doesn't have an alpha channel.
 *
 **/
/**
\brief      Obtain colour and alpha values from an RGBA pixBuf.
\author     William J Giddings
\date       06/03/10
\since      0.9.94
\note       Adaptation of gdk_pixbuf_fill
**/
void gdk_pixbuf_set_pixel ( GdkPixbuf *pixbuf, guint32 pixel, guint x, guint y )
{
	guchar *pixels;
	guint r, g, b, a;
	guchar *p;
	guint w, h;
	guint rowstride, n_channels;

	g_return_if_fail ( GDK_IS_PIXBUF ( pixbuf ) );

	w = gdk_pixbuf_get_width ( pixbuf );
	h = gdk_pixbuf_get_height ( pixbuf );

	if ( w == 0 || h == 0 )
	{
		return;
	}

	if ( x > w || y > h )
	{
		return;
	}

	pixels = gdk_pixbuf_get_pixels ( pixbuf );
	rowstride = gdk_pixbuf_get_rowstride ( pixbuf );
	n_channels = gdk_pixbuf_get_n_channels ( pixbuf );

	r = ( pixel & 0xff000000 ) >> 24;
	g = ( pixel & 0x00ff0000 ) >> 16;
	b = ( pixel & 0x0000ff00 ) >> 8;
	a = ( pixel & 0x000000ff );

	p = pixels + y * rowstride + x * n_channels;

	switch ( n_channels )
	{
		case 3:
			{
				p[0] = r;
				p[1] = g;
				p[2] = b;
			}
			break;
		case 4:
			{
				p[0] = r;
				p[1] = g;
				p[2] = b;
				p[3] = a;
			}
			break;
		default:
			break;
	}
}


